# Rust 任务调度系统

> 实现一个**并发的异步任务调度器**, 满足「按 id 去重」「失败打印日志」「最大并发数可控」等要求, 并配套必要的测试用例与简短说明文档.请在合理时间内做出可维护, 可扩展, 代码风格优雅的实现.
> 基于现有的异步生态完成就行, 并不需要自己实现runtime, 只是调度异步任务.
> 请规范的提交到github上.

---

## 背景

我们在服务端经常需要并发执行大量任务(例如抓取, 转码, 账单结算).为了控制资源与结果一致性, 需要:

* 同一个任务 id 在同一时间**只允许一个实例在运行**(去重/合并).
* 全局有**最大并发数**上限, 防止把机器打满.
* 任务失败需要**记录日志**, 便于观测与排错.

你将实现一个轻量的**任务调度系统**来达成以上目标.

---

## 功能需求

1. **异步并发调度**: 能够同时运行多个任务(使用 async 生态), 并在达到上限后进行排队/阻塞.
2. **按 id 去重**: 当一个 id 的任务正在运行时, 再次提交相同 id 的任务:

   * 该提交不会启动第二个实例;
   * 返回一个可观察的状态(例如 `SkippedDuplicate`), 以便调用方知道被去重了;
   * 一旦该 id 的任务结束(成功或失败), 后续相同 id 的提交才可再次调度.
3. **最大并发数控制**: 可在构造调度器时指定并发上限(如 `max_concurrency: usize`).
4. **失败日志**: 任务 `run()` 返回错误时, 打印含任务 id 的日志(不要求日志聚合, 仅需可读).
5. **可关闭**: 提供优雅关闭(graceful shutdown)能力:

   * 拒绝新的提交;
   * 等待已在运行/已入队的任务按设计完成, 或在一个超时后取消(超时策略可选).

---

## 非功能需求

* **可读性与优雅实现**: 更倾向清晰, 解耦的抽象与错误处理, 而非“能跑就行”.
* **测试覆盖**: 至少覆盖以下场景:

  * 去重: 相同 id 被去重;任务完成后可再次提交.
  * 并发: 并发上限生效;队列/阻塞正确.
  * 失败日志: 制造失败任务, 验证有日志输出(可通过 `tracing` 的测试订阅器或捕获 stdout/stderr).
  * 关闭: `shutdown()` 行为符合预期.
* **文档**: `README.md` 简述设计权衡与如何运行测试.

---

## 加分项(任选其一或多项)

* **重试与退避**: 给失败任务实现指数退避重试(限制最大重试次数), 并记录重试次数.
* **任务合并(coalescing)**: 当同 id 的任务重复提交时, 允许后续调用者**订阅已有任务结果**, 而不是简单跳过.
* **超时/取消**: 支持每个任务的超时与取消(例如 `tokio::time::timeout`).
* **度量指标**: 提供简单 metrics(如 `prometheus`), 记录排队长度, 运行中数, 失败数.
* **可观察性**: 为核心路径添加 `tracing` span 与关键事件.

--

## 提交方式

* 提交 Git 仓库链接.

---

## 我们期待看到的

* 清晰的并发模型(如: **Semaphore 限流** + **运行中 id 集合** + **drop 后释放资源**).
* 对竞态条件的思考: 提交-检查-插入的原子性;任务结束后的清理;关闭与提交的竞态.
* 朴素但可验证的实现优于过度工程化.请优先保证**正确性**与**可读性**.